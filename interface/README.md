# Інструменти для створення користувацького інтерфейсу  
## Маніпулювання DOM елементами за допомогою JavaScript:      
1. В [прикладі](singlepage.html) кожний елемент буде зображено в окремому блоці `<div>`  
2. По-перше приховаємо всі елементи `<div>`  за допомогою `CSS`:  
```css
div {
    display: none;
}
```   
3. Тепер на html сторінці створимо `dataset` для кожної кнопки:
```html 
<button data-page="page1">Перша сторінка</button>
```
4. Додамо текст кожного блоку `<div>` (сторінки) які потім за потреби по черзі будемо відкривати функцією showPage:  
```js
function showPage(page) {
    // Показати div, переданий у аргументі функції
    document.querySelector(`#${page}`).style.display = 'block';
}
```
5. Обробляти натискання на кнопки, та викликати згадану функцію теж буде JS:  
```js
    // Обрати всі кнопки
    document.querySelectorAll('button').forEach(button => {
        // Коли кнопку натиснуто, викликати функцію показу блоку з обраним id 
        button.onclick = function() {
            showPage(this.dataset.page);
        }
    })
``` 
## Маніпулювання елементами DOM за допомогою AJAX
1. Зробимо застосунок Django з назвою `singlepage`  

![singlepage](.img/ajax.jpg)  

2. Отже в застосунку у нас є три сторінки з різними URL-адресами нашталт http://127.0.0.1:8000/sections/1 що містять тільки тексти.  

![singlepage](.img/section1.jpg)  

3. Основна сторінка проекту [index.html](singlepage\singlepage\templates\singlepage\index.html) буди містити код з кнопками функціонально схожий на код з першого прикладу, але основна функція в ній `showSection(section)` буде маніпулювати не видимістю блоків дів, а буде зчитувати тексти з відповідних кнопкам URL-адрес.   

4. Отже все окрім завантаженого тексту на сторінці не змінюється, але URL-адреса теж залишається не змінною, хоча це було б корисно для швидкої навігації та прямого переходу до потрібного контенту.  

## Історія змін та прямий доступ до контенту сторінки за URL-адресою.
1. Тут на допомогу нам новий інструмент [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) у JavaScript.  
2. Додамо в [застосунок](singlepage2\singlepage\templates\singlepage\index.html) код API що дозволить використовувати історію:  

```js
window.onpopstate = function(event) {
    console.log(event.state.section);
    showSection(event.state.section);
}

//Додати поточний стан до історії за допомогою наступної функції з трьома аргументами 
        history.pushState({section: section}, "", `section${section}`);
        showSection(section); 
```  
3. Таким чином ми отримаємо пряму адресу для доступу до контенту http://127.0.0.1:8000/section3 , та історію переходів між сторінками.


## Об'єкт window та прокрутка
Об'єкт `window` відрізняється від `document` тим що він відповідає за ту частину багатосторінкового документа яку ми бачимо на екрані, та має наступні властивості:    
- `window.innerWidth:` ширина вікна в пікселях.
- `window.innerHeight:` висота вікна в пікселях.  
- `window.scrollY:` скільки пікселів ми прокрутили від верхньої частини сторінки.
- `document.body.offsetHeight:` висота всього документа в пікселях.
- `window.scrollY + window.innerHeight >= document.body.offsetHeight` - чи прокрутив користувач до кінця сторінки.
Наступний js-код демонструє як працює функція прокрутки до кінця вікна:  
```js
// Слухач події прокручування
window.onscroll = () => {
    // Перевірити, чи ми внизу сторінки
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
        // Змінити колір фону на червоний
        document.querySelector('body').style.background = 'red';
    } else {
        // Змінити колір фону на зелений
        document.querySelector('body').style.background = 'green';
    }
};
``` 

На практиці цю властивість часто використовують для реалізації безкінечної прокрутки:
- за вищенаведеним механізмом дізнаємось чи дійшов користувач до кінця сторінки
- використовуючи js додаємо додатковий зміст

Отже створимо [застосунок Django](posts\posts\views.py) який генеруватиме нам потрібну кількість тестових постів форуму наприклад.  
Після запуску застосунку та вказавши в якості url: `http://127.0.0.1:8000/posts?start=10&end=20` отримаємо наступну відповідь у форматі JSON:  
```JSON
{"posts": ["Post#10", "Post#11", "Post#12", "Post#13", "Post#14", "Post#15", "Post#16", "Post#17", "Post#18", "Post#19", "Post#20"]}
```
Тепер створимо основну сторінку сайту [index.html](posts\posts\templates\scroll\index.html), яка буде містити порожній елемент DIV, що буде заповнюватись кодом JS в залежності від положення вікна у документі.

На початку коду html-сторінки ми вказуємо місце знаходження [файлу JavaScript](posts\posts\static\posts\script.js) у нашій теці static, та додаємо його туди. Нижче як раз та частина коду, яка вираховує кінець документу, та довантажує новий контент, роблячи сторінку нескінченою:   
```js
// Якщо користувач дійшов кінця сторінки, завантажити наступні 20 дописів
window.onscroll = () => {
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
        load();
    }
};
```

## Анімація за допомогою CSS  
Для створення анімації в файлі CSS використовують один з варіантів:  
- вказуючи стилі на початку та на закінченні анімації (to та from)  
```css
@keyframes animation_name {
    from {  /* Якісь стилі для початку */}
    to {/* Якісь стилі для завершення */}
}
```
- вказуючи стилі на різних етапах тривалості анімації (від 0% до 100%)
```css
@keyframes animation_name {
    0% { /* Якісь стилі для початку */ }
    75% {/* Якісь стилі після 3/4 анімації */}
    100% { /* Якісь стилі для завершення */}
}
```
Для застосування анімації до елемента описуємо в [його властивостях](https://www.w3schools.com/cssref/css3_pr_animation.php):  
- `animation-name` ім'я анімації
- `animation-duration` тривалість анімації (у секундах)
- `animation-iteration-count` кількість повторювань анімації (`infinite` для нескінченної анімації)
- `animation-fill-mode` режим заповнення анімації:
    * `none` - стилі не будуть застосовані до елемента
    * `forwards` - по завершенню анімація елемент збереже стилі останнього ключового кадру
    * `backwards` - по завершенню анімація елемент збереже стилі першого ключового кадру
    * `both` - по завершенню анімація елемент збереже стилі першого та останнього ключових кадрів

Докладніше дивіться у наступних прикладах кода:
- [збільшення розміру тексту](animate.html).
- [положення тексту на сторінці](animate1.html).
- [збільшення розміру тексту а потім зменшення і так до нескінченності](animate2.html).
- [останній фрагмент коду з додаванням JavaScript для керування анімацією](animate3.html).  

**Спробуємо використати отриманні знання для удосконалення раніше створеного проекту Django:**  
- додамо у [файлі скрипту](posts2\posts\static\posts\script.js) кнопку в функцію `add_post`, що генерує дописи:
```js
post.innerHTML = `${contents} <button class="hide">Приховати</button>`;
``` 
- тепер потрібно зробити обробник подій при натисканні на додану кнопку. Тут будемо використовувати клас parentElement, щоб знайти батьківський елемент цього елемента в DOM.:  
```js
document.addEventListener('click', event => {
    const element = event.target; // Знайти, що було натиснуто
    if (element.className === 'hide') {  
        element.parentElement.remove()
    }
});
```
- на цьому етапі наче все працює, але дописи зникають мит'єво, та користувач може не зрозуміти що змінюється на сторінці, тому тут самий час використати анімацію. 
- додамо в [CSS-файл](posts2\posts\static\posts\styles.css)  `@keyframes`, що описує анімацію, яка складається з двох частин: в першій змінює прозорість елементу DIV, а в другій його висоту, змушуючи поступово зникати.
- тепер ми маємо доповнити обробник натискання на кнопку так щоб мін запускав анімацію, що ми призупинили раніше:  
```js
element.parentElement.style.animationPlayState = 'running';
``` 
- також потрібно буде дочекатись завершення анімації, а лише потім видаляти відповідний натиснутій кнопці елемент, для чого додаємо ще одного слухача подій `animationend`:   
```js
element.parentElement.addEventListener('animationend', () => {
    element.parentElement.remove()   
})
``` 
## React
1. Основна перевага бібліотеки React в порівняні з прямим використанням JavaScript це **декларативне програмування**. Тоб то ми декларуємо зміну прямим кодом на сторінки, а потім виконуємо над нею операцію: 
```
<h1>{num}</h1>
num += 1;
``` 
Раніше ми мали справу тільки з **імперативним програмуванням**, ця ж сама, проста логіка реалізується наступним чином:
- В коді html фіксуємо конкретне значення елементу моделі DOM: `<h1>0</h1>`
- В коді JS шукаємо цей елемент: `document.querySelector("h1")`
- Визначаємо значення елемента, конвертуємо його в число: `= parseInt(document.querySelector("h1").innerHTML);`
- Зберігаємо значення в змінну: `let num = `
- Виконується математична дія над змінною: `num += 1;`
- Знов знаходиться потрібний елемент в документі, та замінюється значенням отриманої змінної: `document.querySelector("h1").innerHTML = num;`

Основна ідея фреймворку React базується на використанні **компонентів**, те що користувач бачить на сторінці, та їх **станів**, які формуються за допомогою змінних та функцій в коді програми. React забезпечує зміну миттєву зміну компонентів моделі DOM сайту відразу за зміною їх стану.

Існує безліч [інструментів та способів використання React](https://uk.reactjs.org/docs/create-a-new-react-app.html), але зараз розглянемо наступні пакети для роботи з файлами html:  
* `React:` - визначає компоненти та їхню поведінку;
* `ReactDOM:` - бере компоненти React і вставляє їх у DOM;
* `Babel:` - конвертує мову React JSX в звичайний JavaScript, що можуть інтерпретувати браузери.

2. Створимо простий застосунок з React та прокоментуємо його у середині [кода](react.html)

3. В [наступному прикладі](react1.html) продемонструємо як ми можемо замінити однакові елементи одного компонента використанням всередині нього посиланням на інший компонент, описаний вище. Отже в файлі оптимізовано наступний код компонента(функції):  
```jsx
function App() {
    return (
        <ul> 
            <h1><li><i>Привіт!</i></li></h1>
            <h1><li><i>Привіт!</i></li></h1>
            <h1><li><i>Привіт!</i></li></h1>
        </ul>
    );
}   
```

4. Ускладнюємо задачу використанням параметру або змінної яку будемо передавати між компонентами в [наступному коді](react2.html).

5. Спробуємо передавати компонентам не тільки властивості, але й стан, тоб-то дані, які ми хочемо вивести в середину компоненту. 
- Для цього напишемо [код лічильника](react_counter.html), з аналогічним функціоналом як ми робили в лекції по JS. 
- Використаємо [хук](https://uk.reactjs.org/docs/hooks-intro.html) React `useState`, щоб додати стан до нашого компонента:
```jsx
const [count, setCount] = React.useState(0);
// де функція повертає:
// count - значення змінної, що представляє стан
// setCount - функція яка дозволяю змінювати стан
```
- Також потрібен слухач подій, що буде реагувати на натискання кнопки за допомогою атрибута onClick:
```jsx
return (
    <div>
        <h1>{count}</h1>
        <button onClick={updateCount}>Обрахунок</button>
    </div>
);
```
- Додамо функцію `updateCount`, в якій скористаємось функцією `setCount`, яка може приймати як аргумент нове значення для стану:  
```jsx
function updateCount() {
    setCount(count + 1);
}
```

# Створення застосунку "Додавання" за допомогою React

1. Створимо наш застосунок у [файлі](addition.html) по шаблону попереднього завдання.
2. Для вводу даних будемо використовувати контрольований React компонент `input`:  

[React має два різних підходи для керування формами:](https://uk.reactjs.org/docs/glossary.html#%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BE%D0%B2%D0%B0%D0%BD%D1%96-%D1%82%D0%B0-%D0%BD%D0%B5%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BE%D0%B2%D0%B0%D0%BD%D1%96-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B8)

Елемент форми `input`, чиє значення контролюється React, називається **контрольованим компонентом**. Коли користувач вводить дані у контрольований компонент, викликається обробник події зміни і ваш код вирішує чи є ввід допустимим (input повторно рендериться з оновленим значенням). Якщо ви не рендерите елемент форми повторно, то він лишиться без змін.

**Неконтрольований компонент** працює як звичайний елемент форми поза межами React. Коли користувач вводить дані в поле форми (поле вводу, випадаючий список і т. д.), оновлена інформація відображається без участі React. Однак це також означає, що ви не можете присвоїти полю певні значення.

3. Задача полягає в тому, щоб згенерувати математичне запитання, а в полі вводу надати на нього відповідь. От же опишемо два елементи стану, які будуть динамічно формувати запитання:
```jsx
        const [num1, setNum1] = React.useState(1);
        const [num2, setNum2] = React.useState(2);
```
Але в разі більшої кількості станів такий запис буде виглядати не компактно, отже спростимо його за допомогою об'єкта JS:
```jsx
        const [state, setState] = React.useState({
            num1: 1,
            num2: 2
        });
```
4. Тепер додамо в цей масив змінні для обробки результату:  
- `response: "",` для зберігання результату вводу
- `score: 0` для підрахунку балів

5. Додамо атрибут [onChange](https://uk.reactjs.org/docs/dom-elements.html#onchange) до елемента `input` і встановимо його рівним функції під назвою `updateResponse`, яка буде приймати подію, що ії запустила, та встановлювати значення response на те що введено в полі вводу:
```jsx
function updateResponse(event) {
    setState({
        ...state,  // оператор розширення JS, який дозволяє не описувати для встановлення статусу ті елементи, що не змінились  
        response: event.target.value
    });
}
```
6. Додамо ще один атрибут `onKeyPress` до елемента `input`, який викликатиме функцію-обробник `inputKeyPress`, що дозволить запам'ятовувати та обробляти відповідь введену користувачем:  
```jsx
function inputKeyPress(event) {
    if (event.key === "Enter") {
        const answer = parseInt(state.response);
        if (answer === state.num1 + state.num2) {
            // Користувач відповів правильно
        } else {
            // Користувач відповів неправильно
        }
    }
}
```
7. Додамо ще один атрибут `autoFocus` до елемента `input` та встановимо його значення в {true}, що при оновлені сторінки курсор завжди фокусувався на полі вводу.

8. Щоб генерувати постійно нові запитання скористаємося функціями:
`Math.random()` - генерує випадкове число від 0 до 1
`Math.ceil()` - функція що округлює значення до цілих чисел

9. Застосунок працює як треба, тепер самий час додати стилю в секції CSS: 
```css
#app {
    text-align: center;
    font-family: sans-serif;
}

#problem {
    font-size: 72px;
}
```
10. Також ми маємо можливість змінювати стилі елементів в залежності від результатів, для цього змінюємо нову змінну `incorrect`, в залежності від результату та використаємо умовне встановлення класу атрибута DIV:  
```jsx
className={state.incorrect ? "incorrect" : "correct"}
```

11. Нарешті зробимо гру з можливістю перемоги при досягненні 5 балів, за допомогою додавання умови до функції `render`:  
```jsx
if (state.score === 10) {
    return (
        <div id="winner">Ви перемогли!</div>
    );
}
```

# Завдання 4: Створити власну соціальну мережу
## Запуск проекту
1. Клонувати сховище на локальний комп'ютер:  
`git clone https://github.com/vit-um/vit-um.github.io.git`

2. Перейти у теку проекту:  
`cd interface\project4`  

3. Створити міграції для застосунку network:   
`python manage.py makemigrations network`

4. Застосувати міграції до нашої бази даних:  
`python manage.py migrate`

5. Для заповнення створеної БД через інтерфейс `http://127.0.0.1:8000/admin/` та контролю за коректністю створення полів заведемо суперкористувача з можливістю керування БД:  
`python manage.py createsuperuser`  

5. Запустити сервер:  
`python manage.py runserver`  

## Створення бази даних для зберігання даних застосунку  
1. Для початку відкриємо файл БД та подивимось які поля вже в моделі `AbstractUser`, з які били клоновані поля для нашої моделі `Users`  

![sql](.img/sql0.jpg)

2. Додамо до моделі `User` в файлі [models.py](project4\network\models.py) поле з зв'язком "багато до багатьох", що буде зберігати користувачів, за якими слідкує користувач:  
```python
class User(AbstractUser):
    following = models.ManyToManyField("User", blank = True, verbose_name="Слідкую", related_name="followers")

    def __str__(self):
    return f"{self.id}: {self.username}  |  {self.first_name} {self.last_name}  |  {self.email}"

```
- Один користувач може слідкувати відразу за багатьма так само як і кожний окремо взятий користувач може слідкувати за цим користувачем. Для зручності пошуку в базі користувачів, що слідкують за обраним користувачем додаємо параметр:  `related_name="followers"`  

- Додане поле може бути порожнім, от же вкажемо  
`blank = True`  

- Нам буде зручно якщо додане поле в адміністративному інтерфейсі буде підписано зрозумілим значенням, от же задаємо його:  
`verbose_name="Слідкую"`  

- Та нарешті в `def __str__(self)` визначаємо формат назви запису, як він буде виглядати в адміністративному інтерфейсі:  

![adm](.img/admin.jpg)  

3. В файлі [admin.py](project4\network\admin.py) додамо потрібні моделі для відображення в адміністративному інтерфейсі та опишемо їх класи:  
```python
from .models import User, Posts

class UserAdmin(admin.ModelAdmin):
    list_display = ("id", "username", "first_name", "last_name", "email")
    filter_horizontal = ("following",)
    
class PostsAdmin(admin.ModelAdmin):
    # додамо назви стовпців до таблиці з записами моделі
    list_display = ("id", "author", "timestamp", "post", "likes") 
    # Створює зручний фільтр для поля з відношенням багато до багатьох
    filter_horizontal = ("users_like",) # Створює зручний фільтр для поля з відношенням багато до багатьох
    
# Реєструємо моделі
admin.site.register(User, UserAdmin)
admin.site.register(Posts, PostsAdmin)
```
## Новий допис  
Користувачі, котрі ввійшли до облікових записів, повинні мати змогу написати новий текстовий допис, увівши текст до текстового поля і натиснувши кнопку для публікації допису.  

![new_post](.img/new_post.gif)  

## Усі дописи  
Посилання «Усі дописи» на панелі навігації має переносити користувача на сторінку, де він може побачити всі дописи від усіх користувачів, починаючи від найсвіжіших. Кожен допис має містити:  
- логін користувача-автора, 
- текст допису, 
- дату й час його публікації,  
- кількість поставлених допису лайків 

![new_post](.img/all_posts.jpg)

## Сторінка профілю
Натискання на ім’я користувача має завантажувати сторінку профілю цього користувача. Ця сторінка має:  
- Виводити кількість підписників цього користувача та кількість осіб, за якими стежить цей користувач.  
- Показувати всі дописи цього користувача в зворотному хронологічному порядку.  
- Для будь-якого іншого користувача, що увійшов у свій обліковий запис, ця сторінка має також показувати кнопку «Підписатись» чи «Відписатись», яка дозволить користувачу стежити чи не стежити за дописами власника профілю.   

Зверніть увагу, що це стосується лише «інших» користувачів, користувач не повинен мати можливість стежити за самим собою.

![new_post](.img/profile.jpg)  
![new_post](.img/profile.gif)  

## Підписки
Посилання «Підписки» на панелі навігації має переносити користувача на сторінку, де він бачитиме всі дописи, зроблені користувачами, за котрими він стежить.  
- Ця сторінка має поводитися так само як сторінка «Усі дописи», але містити обмежений набір дописів.  
- Ця сторінка має бути доступною лише для користувачів, що увійшли в обліковий запис. 

![new_post](.img/followers.jpg) 

## Редагувати допис
Користувачі повинні мати можливість натиснути на кнопку чи посилання «Редагувати» поруч з кожним своїм дописом, щоб змінити його.  
- Коли користувач натискає «Редагувати» для одного з власних дописів, наповнення має перетворитися на текстове поле textarea, в якому користувач зможе змінити вміст допису.   
- Після цього користувач повинен мати змогу «Зберегти» відредагований допис. За допомогою JavaScript ви повинні досягти цього без потреби перезавантажувати всю сторінку.  
- З міркувань безпеки переконайтеся, що ваш застосунок спроєктовано так, щоб користувачі за жодним з маршрутів не могли змінювати дописи інших користувачів.  

![new_post](.img/edit.gif)  

## Лайк та Прибрати лайк
Користувачі повинні мати можливість натиснути на кнопку чи посилання поряд з будь-яким дописом, щоб поставити йому лайк чи прибрати його.
За допомогою JavaScript ви маєте асинхронно повідомити серверу, щоб він оновив кількість лайків (як через виклик fetch) і потім оновити кількість лайків допису, поданих на сторінці, без потреби перезавантаження усієї сторінки.

![new_post](.img/likes.gif)  
